.\" Man page generated from reStructuredText.
.
.TH "HYBRID" "1" "May 31, 2017" "1.0" "Hybrid"
.SH NAME
hybrid \- hybrid Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH HYBRID
.sp
A simple web application to manage and access the services running on your home server.
.SH MOTIVATION
.sp
Well at home I have an old Raspberry Pi I use as a small home server. The services I use on it are SiCKRAGE, Transmission and Kodi.
.sp
Since the Pi is not very powerful, running too many services at the same time on it reduces performance. This translates in poorer quality of the movies and TV\-Shows I watch through Kodi Mediacenter.
Originally I used to connect via SSH to Hybrid Server each time and stop services I didn’t need running.
.sp
Then I found out that Kodi and Transmission have pretty great web user interfaces. So basically, if I made Hybrid Server available even from outside my home LAN, I could enjoy my media content and use all the services Hybrid Server has to offer remotely, using a nice GUI.
.sp
Of course, if I wanted an all ‘round GUI experience I needed a way to manage those services, namely turning them on and off from a web user interface.
.sp
This is when the idea for this project came to me. Also facilitated by the fact that I was looking for a project idea like this to renew my ability in web development, which had become very outdated and sloppy after years of inactivity in that field.
.INDENT 0.0
.INDENT 3.5
.IP "TL;DR"
.sp
This web application provides an entrance (a hall if you wish) to access the services running on the server that have a web GUI, as well as a way to manage their state.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The scope of this project may seem very specific and in some sense it is. What I think makes this useful is that it contains the barebone structure of a working website with some basic functionality.
.sp
For this reason \fBHybrid\fP is very easy to adapt for projects that have nothing to do with its original scope.
Hence I encourage you to fork it and to make it your own.
.UNINDENT
.UNINDENT
.SH IN THIS DOCS
.SS cookiebaker
.SS Synopsis
.sp
This module contains the implementation of the \fBCookieBaker\fP class.
.sp
\fBCookieBaker\fP is a class implementing a manager of long\-lived (as opposed to session\-lived) login cookies.
.SS Long\-lived cookies
.sp
Cookies consist of couples
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(cookieKey, cookieVal)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For our purpose cookieKey will always be \fBrememberme\fP\&.
.INDENT 0.0
.TP
.B In this implementation, \fBcookieVal\fP is obtained as follows:
.INDENT 7.0
.IP \(bu 2
Make a dictionary with the username as key and some random bytes from urandom as value.
.IP \(bu 2
Encode and sign this data using the JSON Web Signature (JWS) standard.
.UNINDENT
.UNINDENT
.SS Members
.INDENT 0.0
.TP
.B class cookiebaker.CookieBaker(cookieStorageFile, key, salt=None, cookieSize=33)
CookieBaker is a manager of long\-lived (as opposed to session\-lived) login cookies.
.sp
This is a very convenient feature for a web app to have, but only conscious users who are responsible with their cookies should use it.
This cookie management system is secure, as long as the connection to the service is end\-to\-end encrypted AND the user is responsible with their cookies.
.sp
\fBIMPORTANT:\fP
.INDENT 7.0
.INDENT 3.5
Upon creation of a new instance of CookieBaker, the cookie database file passed is pruned from all expired cookies, by calling the function \fI\%CookieBaker.pruneCookieDB()\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcookieStorageFile\fP (\fIstr.\fP) – The XML file used as a db for login cookies.
.IP \(bu 2
\fBkey\fP (\fIstr.\fP) – The secret key used to sign cookies.
.IP \(bu 2
\fBsalt\fP (\fIstr.\fP) – Not a cryptographic salt per se, but it can be used to alter the signing key for cookies with different functions (unused).
.IP \(bu 2
\fBcookieSize\fP (\fIint.\fP) – The size in bytes of the cookie (default value is 33)
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B bake(userid)
Generate and sign a new \fBcookieVal\fP\&.
.sp
This is the JSON Web Signature (JWS) of the dictionary type data in (pseudo\-code):
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
{ "userid" : "base64(randomBytes)" }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
where randomBytes are \fBcookieSize\fP cryptographically secure random bytes (from \fBurandom\fP).
.sp
An example of such a JWS value is:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
eyJhbGciOiJIUzI1NiJ9.eyJ4Ijo0Mn0.ZdTn1YyGz9Yx5B5wNpWRL221G1WpVE5fPCPKNuc6UAo
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBuserid\fP (\fIstr.\fP) – The username of the user for which we generate the new cookie.
.TP
.B Returns
str – The \fBcookieVal\fP for the new cookie, signed with the \fBkey\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B check(cookieVal)
Check cookie integrity and wether \fBcookieVal\fP corresponds to an entry in our \fBcookieStorageFile\fP\&.
.sp
Another advantage of using JWS (apart from serialization) is that it enables us to notice if a cookie has been tampered with.
This is because cookies are signed with a key.
.sp
This function first verifies that the cookie presented was signed by this application’s key and that was not tampered with.
If all goes well it checks if there exists a user with that \fBcookieVal\fP in the cookie database.
.INDENT 7.0
.TP
.B Parameters
\fBcookieVal\fP (\fIstr.\fP) – the \fBcookieVal\fP to check. Typically it is a cookie sent by the client.
.TP
.B Returns
str, NoneType – the username of the owner of the cookie if the check succeeds or \fBNone\fP if it fails.
.TP
.B Raises
\fBxml.etree.ElementTree.ParseError\fP, \fBitsdangerous.BadSignature\fP, \fBOSError\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B delete(cookieVal)
Remove a cookie from the cookie database, if it is there.
.INDENT 7.0
.TP
.B Parameters
\fBcookieVal\fP (\fIstr.\fP) – the \fBcookieVal\fP to delete.
.TP
.B Returns
bool – \fBTrue\fP if deletion occurred successfully, \fBFalse\fP otherwise.
.TP
.B Raises
\fBxml.etree.ElementTree.ParseError\fP, \fBOSError\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B pruneCookieDB()
Remove all expired cookies from the cookie database.
.sp
This is called automatically when a new CookieBaker is created, to ensure that the cookie database does not fill up with useless data.
.INDENT 7.0
.TP
.B Returns
bool – \fBTrue\fP if cookies were pruned, \fBFalse\fP otherwise.
.TP
.B Raises
\fBxml.etree.ElementTree.ParseError\fP, \fBOSError\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B store(cookieVal, expiration=None)
Store a \fBcookieVal\fP in the \fBcookieStorageFile\fP\&.
.sp
What is actually stored is the bcrypt salted hash of \fBcookieVal\fP\&.
Each user can have many long\-lived valid cookies at once (e.g. they could access the web app from more than one device).
To permit this, the cookie database is of the form:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
<cookiedb>
  <user username="alice">
    <cookie expiration="1496055235">$2b$12$qOVm.1JJFgsCtYRWTanaIu/VcZK8b1CATxIVLzWv7oSKksrVGttee</cookie>
    <cookie expiration="1496051234">$2b$12$NQYMCavxqcu80dDNFMadjOs/f6iWK1.HaWwEIyAG9Iy68bq7FeGpy</cookie>
  </user>
  <user username="chftyrol">
    <cookie expiration="1496055777">$2b$12$4nmV2L38SP5XX7xDalM0B.ISJil/4wimUaMw13j6HtMhwDVnRT3ce</cookie>
  </user>
</cookiedb>
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBcookieVal\fP (\fIstr.\fP) – a \fBcookieVal\fP to store, as produced by \fI\%bake()\fP\&.
.TP
.B Raises
\fBxml.etree.ElementTree.ParseError\fP, \fBOSError\fP\&.
.TP
.B Returns
bool – \fBTrue\fP if operation is successful, \fBFalse\fP otherwise.
.UNINDENT
.UNINDENT
.UNINDENT
.SS helpers
.SS Synopsis
.sp
This module contains the definition of a few helper classes and functions used by \fBHybrid\fP\&.
.sp
Most of the contents of this module are simple classes like \fBAction\fP, \fBLink\fP etc. used to represent structured data types and nothing more.
A few custom exceptions are also defined.
.sp
There are also a couple of methods not belonging to any class, such as the hybrid utterance generator.
.SS Members
.INDENT 0.0
.TP
.B class helpers.Action(which, description)
Represents a possible action to perform on a service, for example start, disable, navigate, etc.
Example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
>>> restartAction = Action("restart", "⟳")
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBwhich\fP (\fIstr.\fP) – Specify which action is to be taken. Valid values are only: \fBstart\fP, \fBstop\fP, \fBrestart\fP, \fBenable\fP, \fBdisable\fP, \fBnavigate\fP\&.
.IP \(bu 2
\fBdescription\fP (\fIstr.\fP) – Symbol or text describing the action.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B exception helpers.ActionNotAllowedException(action)
Exception raised when client tries to do an unallowed Action with a certain service.
.INDENT 7.0
.TP
.B Parameters
\fBaction\fP (\fIstr.\fP) – The forbidden action which was attempted to be performed.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B exception helpers.InvalidServiceRequest
Base class for exceptions about performing unallowed Actions of performing actions on unallowed Targets.
.UNINDENT
.INDENT 0.0
.TP
.B class helpers.Link(href, caption)
Simple class used to pass Link objects to Jinja HTML templates.
Example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
>>> redditLink = Link("https://reddit.com/r/owlsinhats", "Check out some cool looking owls wearing hats!")
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhref\fP (\fIstr.\fP) – The target of the link.
.IP \(bu 2
\fBcaption\fP (\fIstr.\fP) – The text displayed on the link.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class helpers.Service(title, description, id, actions, measureMethod, actionMethod, measurementInstrument, actionInstrument, navigateHref)
Entity corresponding to an entry in HSM.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtitle\fP (\fIstr.\fP) – the title of the service item, as displayed in HSM webpage.
.IP \(bu 2
\fBdescription\fP (\fIstr.\fP) – a description of the service item, as displayed in HSM webpage.
.IP \(bu 2
\fBid\fP (\fIstr.\fP) – an id string for reference. It is used in many places, namely as class attribute in HSM for elements relative to a service, in the config file as a section id.
.IP \(bu 2
\fBactions\fP (\fIList\fP) – a list of allowed Action objects that can be performed with this Service.
.IP \(bu 2
\fBmeasureMethod\fP (\fIstr.\fP) – either \fBsystemd\fP, \fBsystemd\-user\fP or \fBScript\fP\&. This specifies how the measurement of status of the service will be performed.
.IP \(bu 2
\fBactionsMethod\fP (\fIstr.\fP) – either \fBsystemd\fP, \fBsystemd\-user\fP or \fBScript\fP\&. This specifies how actions on the service will be performed.
.IP \(bu 2
\fBmeasurementInstrument\fP (\fIstr.\fP) – .INDENT 2.0
.IP \(bu 2
if \fBmeasureMethod\fP is \fBsystemd\fP it is the systemd unit probed for \fBis\-active\fP and \fBis\-enabled\fP properties;
.IP \(bu 2
if \fBmeasureMethod\fP is ‘systemd\-user’ it is the user systemd unit probed for \fBis\-active\fP and \fBis\-enabled\fP properties;
.IP \(bu 2
if \fBmeasureMethod\fP is \fBScript\fP it is the full path to a script which must return a string concatenating either \fBactive\fP, \fBinactive\fP, \fBunknown\fP (for the is\-active part) and either \fBdisabled\fP, \fBenabled\fP, \fBunknown\fP (for the \fBis\-enabled\fP part)
.UNINDENT

.IP \(bu 2
\fBactionInstrument\fP (\fIstr.\fP) – .INDENT 2.0
.IP \(bu 2
if \fBmeasureMethod\fP is \fBsystemd\fP or \fBsystemd\-user\fP it is the systemd unit triggered to \fBstart\fP, \fBstop\fP etc.
.IP \(bu 2
.INDENT 2.0
.TP
.B if \fBmeasureMethod\fP is \fBScript\fP it is the full path to a script which performs the following:
.INDENT 7.0
.IP \(bu 2
starts the service when passed the argument \fBstart\fP ;
.IP \(bu 2
stops the service when passed the argument \fBstop\fP ;
.IP \(bu 2
restarts the service when passed the argument \fBrestart\fP ;
.IP \(bu 2
enables the service when passed the argument \fBenable\fP (if available) ;
.IP \(bu 2
disables the service when passed the argument \fBdisable\fP (if available) ;
.UNINDENT
.UNINDENT
.UNINDENT

.IP \(bu 2
\fBnavigateHref\fP – the redirection destination, when performing a \fBnavigate\fP action.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B exception helpers.TargetNotAllowedException(target)
Exception raised when client tries to do something with a target (Service) it is not supposed to work with.
.INDENT 7.0
.TP
.B Parameters
\fBtarget\fP (\fIstr.\fP) – The forbidden target which was attempted to be accessed.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B exception helpers.UnknownActionMethodException(method)
Exception raised when a value for actionMethod differing from either \fBsystemd\fP, \fBsystemd\-user\fP or \fBscript\fP is given
.INDENT 7.0
.TP
.B Parameters
\fBmethod\fP (\fIstr.\fP) – The invalid value of actionMethod that raised this exception.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B exception helpers.UnknownMeasureMethodException(method)
Exception raised when a value for measureMethod differing from either \fBsystemd\fP, \fBsystemd\-user\fP or \fBscript\fP is given
.INDENT 7.0
.TP
.B Parameters
\fBmethod\fP (\fIstr.\fP) – The invalid value of measureMethod that raised this exception.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B exception helpers.UnknownMethodException
Base class for exceptions about invalid measureMethod or actionMethod
.UNINDENT
.INDENT 0.0
.TP
.B helpers.get_services_list(serviceConfFile)
Generate the list of available services the client can operate with.
.sp
It is specified by the conf file \fBserviceConfFile\fP, with the syntax specified in serviceconfsyntax\&.
.INDENT 7.0
.TP
.B Parameters
\fBserviceConfFile\fP (\fIstr.\fP) – the \fBservice.conf\fP file path, containing the specification of the supported services, their measurement and action methods and their allowed actions.
.TP
.B Returns
\fBlist\fP – A list of \fBService\fP objects.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B helpers.get_utterance(utteranceSrcFile)
Generate enough random Hybrid utterance to fill the screen.
.INDENT 7.0
.TP
.B Parameters
\fButteranceSrcFile\fP (\fIstr.\fP) – a file acting as the source for the utterance. It contains one quote of the Battlestar Galactica Hybrids per line.
.UNINDENT
.UNINDENT
.SS hybrid
.SS Synopsis
.sp
This is the main module of hybrid.
It is kept very brief on purpose. Its only functions are to set up the rotating logger and to start the actual web server.
.SS Data
.sp
This module contains the definition of a few important constants (values for file paths are expressed as absolute).
.INDENT 0.0
.IP \(bu 2
\fBLOGIN_DB_FILE\fP \fI(str)\fP \-  a json file containing login data for the clients. It is located in the directory where the python modules reside.
.IP \(bu 2
\fBCOOKIES_DB_FILE\fP \fI(str)\fP \- a json file containing data pertaining permanent cookies. It is located in the directory where the python modules reside.
.IP \(bu 2
\fBSERVICE_CONF_FILE\fP \fI(str)\fP \- a config file defining what services are supported by this web application and their properties.
.IP \(bu 2
\fBCOOKIE_LIFETIME\fP \fI(int)\fP \- how many days should a permanent cookie stay valid for. Value is 90 days.
.IP \(bu 2
\fBAPP_KEY_FILE\fP \fI(str)\fP \- a file containing the key used to sign the cookies. It is located in the directory where the python modules reside.
.IP \(bu 2
\fBLOG_FILE\fP \fI(str)\fP \- the location of the log file. It is located in the directory where the python modules reside.
.IP \(bu 2
\fBPORT\fP \fI(int)\fP \- the port where the server will be accessible from.
.IP \(bu 2
\fBLOGGING_SETTINGS_FILE\fP \fI(str)\fP \- The path to the JSON file containing the configuration of this app for the \fBlogging\fP module.
.UNINDENT
.SS routing
.SS Synopsis
.sp
This module provides the core functionality of the web service.
.sp
It defines the functionality of each web page, the relationships between them and it manages HTTP request, taking action upon them if necessary.
.SS Members
.INDENT 0.0
.TP
.B routing.about()
Render the about page.
.INDENT 7.0
.TP
.B Returns
\fBflask.Response\fP – HTTP response containing the rendered web page
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B routing.hsm()
If user is logged in, render the Hybrid Service Manager web application, otherwise return a response redirecting to the login page.
.INDENT 7.0
.TP
.B Returns
\fBflask.Response\fP – HTTP response containing the rendered web page or the redirect response.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B routing.index()
Render the index page.
.INDENT 7.0
.TP
.B Returns
\fBflask.Response\fP – HTTP response containing the rendered web page
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B routing.init(login_db_file, cookies_db_file, service_conf_file, cookie_lifetime, secret_key_file)
Initialize global variables of this module.
.sp
Information for these comes from hybrid, which specifies the paths for all DB and conf files.
The logging setup also comes from hybrid, which gives us the logger object used in this module.
Also, read the secret key from the appropriate file and set it. This \fBsecret_key\fP is used to sign both session and long\-lived cookies.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBlogin_db_file\fP (\fIstr.\fP) – Path of the json file containing the login data.
.IP \(bu 2
\fBcookies_db_file\fP (\fIstr.\fP) – Path of the json file containing the data pertaining login via permanent cookie.
.IP \(bu 2
\fBservice_conf_file\fP (\fIstr.\fP) – Path of the config file containing the settings for the services offered by the server.
.IP \(bu 2
\fBcookie_lifetime\fP (\fIint.\fP) – How long (in days) should a permanent login cookie remain valid.
.IP \(bu 2
\fBsecret_key_file\fP (\fIstr.\fP) – Path of the file containing the secret key.
.UNINDENT
.TP
.B Raises
\fBOSError\fP
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B routing.iosevka_notice()
Render page with Iosevka Notice Information.
.INDENT 7.0
.TP
.B Returns
\fBflask.Response\fP – HTTP response containing the rendered web page
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B routing.login()
Show the login form, or log the user in directly if the client exhibits a valid rememberme cookie.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
As of now, there is not need for a ‘next’ parameter, as the only thing that needs logging in is HSM.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Returns
\fBflask.Response\fP – HTTP response containing the rendered login web page or the redirect response to HSM.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B routing.login_attempt()
Attempt login via username, password through a POST request.
.sp
For details on this method’s internal workings check \fI\%Login Attempt\fP\&.
.INDENT 7.0
.TP
.B Returns
\fBflask.Response\fP – HTTP response with either:
.INDENT 7.0
.IP \(bu 2
a redirection to HSM.
.IP \(bu 2
a 400 Bad Request HTTP Error (if the request is malformed).
.IP \(bu 2
a 401 Unauthorized HTTP Error (if the credentials are not valid).
.UNINDENT

.TP
.B Raises
\fBjson.JSONDecodeError\fP, \fBOSError\fP
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B routing.measure_status()
Measure the status (is the service running? Is it enabled?) for each service and send the results to the client.
.sp
For details on this method’s internal workings check \fI\%Measure Status\fP\&.
.INDENT 7.0
.TP
.B Raises
\fBUnknownMeasureMethodException\(ga, \(ga\(gasubprocess.CalledProcessError\fP
.TP
.B Returns
\fBflask.Response\fP – HTTP response with the results in JSON format. e.g.
.UNINDENT
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
{"status_all":{"kodi":"unavailable","sickrage":"unavailable","transmission":"inactive disabled"}}
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B routing.perform_action()
Process a request to act on a service of the server.
.sp
For details on this method’s internal workings check \fI\%Perform Action\fP\&.
.INDENT 7.0
.TP
.B Raises
\fBActionNotAllowedException\fP, \fBTargetNotAllowedException\fP, \fBUnknownActionMethodException\fP, \fBUnknownMeasureMethodException\fP, \fBsubprocess.CalledProcessError\fP
.TP
.B Returns
\fBflask.Response\fP – HTTP response with either:
.INDENT 7.0
.IP \(bu 2
a 200 OK code.
.IP \(bu 2
a 403 Forbidden HTTP Error (if the request is for unallawed targets and/or actions).
.IP \(bu 2
a 500 Internal Error code (if a server error occurs while performing the action).
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B routing.start(host, port)
Start web server at the specified host and port
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBhost\fP (\fIstr.\fP) – IP Address to listen to (use 0.0.0.0 to mean all public IPs).
.IP \(bu 2
\fBport\fP (\fIint.\fP) – specify on which port this web server should run.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Details of selected members
.SS Login Attempt
.sp
The function accepts an HTTP \fBPOST\fP request. The data of the request is available to the function through request.form.
request.form is a dictionary containing the data for the login request. It is like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{"attemptedid": "SHA256(attemptedpw)", "rememberme": "i"}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
where \fBi\fP is an integer, taking values 0 (\fB== False\fP) and 1 (\fB== True\fP).
.sp
If the dictionary doesn’t have either 1 or 2 key/value pairs, return a 400 Bad Request.
Otherwise read our \fBloginDBFile\fP\&. Look for an entry with \fBusername\fP == \fBattemptedid\fP\&. If not found return a 401 Unauthorized.
Otherwise with bcrypt do a \fBcheckpw\fP of \fBSHA256(attemptedpw)\fP against the stored password hash for the matching user.
.sp
If passwords don’t match throw a 401 Unauthorized.
Otherwise, log in the user by setting \fBsession[\(aqlogged_in\(aq] = True\fP\&.
This will be checked by other functions when they need to see if the user is logged in.
If the user asked to be remembered bake a signed cookie with \fBCookieBaker\fP\&.
We give it an expiration date and give it to the client.
.SS Perform Action
.sp
Look if the request for action corresponds (by \fBAction\fP and by \fBService\fP) to an allowed combination of \fBAction\fP and \fBService\fP
as specified by the list of \fBhelpers.get_services_list()\fP
.sp
If the request is for anything not allowed raise corresponding exceptions and return a 403 Forbidden error.
Otherwise the request is safe, so we take action.
.sp
The action taken depends on the \fBactionMethod\fP of the \fBService\fP\&.
In case of \fBactionMethod == "systemd"\fP run:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ systemctl <what> <who.unit>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that this approach is highly unrecommended because to be able to operate on global systemd units, the server must be run as root, which is a security hazard.
Instead prefer one of the following two approaches (with the first one being the safest).
.sp
In case of \fBactionMethod == "systemd\-user"\fP run:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ systemctl \-\-user <what> <who.unit>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In case of \fBactionMethod == "script"\fP run:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ <s.actionInstrument> <what>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
where \fBactionInstrument\fP is a custom user script that has to accept the args \fBstart\fP, \fBstop\fP, \fBrestart\fP and if feasible \fBenable\fP and \fBdisable\fP
and act accordingly.
.sp
Manage the possible exceptions. If all is fine, return a 200 OK.
.SS Measure Status
.sp
The way the measurement is done is specified by \fBmeasureMethod\fP: we use systemd units or custom user scripts.
.sp
In any case the output of the command must be of the form:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<A> <E>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
where \fB<A>\fP can be: \fBactive\fP, \fBinactive\fP, \fBunknown\fP
and \fB<E>\fP can be: \fBenabled\fP, \fBdisabled\fP, \fBunknown\fP\&.
.sp
The results of the measurement are put in a JSON like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{"status_all":{"kodi":"unavailable","sickrage":"unavailable","transmission":"inactive disabled"}}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
and sent as a get response to the client.
.SS service.conf
.sp
This file contains the specification of the services supported by the service, their measurement and action methods and their allowed actions.
Having this information hardcoded provides a safe way to operate on the machine services, especially when using systemd units instead of custom scripts.
This is because stuff from the client (presumably unsafe) is never directly written in a command.
Instead we write content from this list’s items and its members.
.SS Syntax
.sp
The file is a very simple config file, with a \fBDEFAULT\fP section and a unique section for each service. The key to each section acts as the \fBid\fP for that service.
The \fBDEFAULT\fP section in that file it propagated to all sections.
.sp
The following fields are recognized in every section:
.INDENT 0.0
.IP \(bu 2
Name: the name of the service.
.IP \(bu 2
Description: a description of what the service does.
.IP \(bu 2
AllowedActions: a comma separated list of the actions that can be performed to the service. The only acceptable values here are: \fBstart, stop, restart, enable, disable\fP and \fBnavigate\fP\&.
.IP \(bu 2
MeasureMethod: one of the following (case insensitive keys):
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBsystemd\fP : status of the service should be measured by checking the status of a systemd unit, specified by \fBMeasurementInstrument\fP\&.
.IP \(bu 2
\fBsystemd\-user\fP : status of the service should be measured by checking the status of a user systemd unit, specified by \fBMeasurementInstrument\fP\&.
.IP \(bu 2
\fBScript\fP : the status of the service should be measured by running a custom script, which full path is specified in \fBMeasurementInstrument\fP\&.
.UNINDENT
.UNINDENT
.UNINDENT
.IP \(bu 2
MeasurementInstrument:
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
if \fBMeasureMethod\fP is either \fBsystemd\fP or \fBsystemd\-unit\fP this must be a systemd unit (a user one in the case of \fBsystemd\-unit\fP)
.IP \(bu 2
if \fBMeasureMethod\fP is \fBScript\fP this is the full path of the custom script. Said script when run should return a string in the form:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
<A> <E>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
where \fB<A>\fP can be: \fBactive, inactive, unknown\fP\&.
and \fB<E>\fP can be: \fBenabled, disabled, unknown\fP\&.
.UNINDENT
.UNINDENT
.UNINDENT
.IP \(bu 2
ActionMethod: same as \fBMeasureMethod\fP, but specify the way we will be operating on the service.
.IP \(bu 2
MeasurementInstrument :
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
if \fBMeasureMethod\fP is either \fBsystemd\fP or \fBsystemd\-unit\fP this must be a systemd unit (a user one in the case of \fBsystemd\-unit\fP)
.IP \(bu 2
if \fBMeasureMethod\fP is \fBScript\fP this is the full path of the custom script. Said script should do the following:
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
start the service when passed the arg \fBstart\fP
.IP \(bu 2
stop the service when passed the arg \fBstop\fP
.IP \(bu 2
restart the service when passed the arg \fBrestart\fP
.IP \(bu 2
enable the service when passed the arg \fBenable\fP (if applicable)
.IP \(bu 2
disable the service when passed the arg \fBdisable\fP (if applicable)
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.IP \(bu 2
NavigateHref: the URL of the destination of the \fBnavigate\fP action.
.UNINDENT
.SS Example
.sp
Below you can find an example of such specification:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[DEFAULT]
AllowedActions=start,stop,restart,enable,disable,navigate

[transmission]
Name = Transmission Daemon
Description = transmission\-daemon is a daemon\-based Transmission session that can be controlled via RPC commands from transmission\(aqs web interface or transmission\-remote. The web interface runs on port 9091 of this server.
MeasureMethod = systemd\-user
ActionMethod = systemd\-user
MeasurementInstrument = transmission.service
ActionInstrument = transmission.service
NavigateHref = http://example.com:9091

[kodi]
Name = Kodi Mediacenter
Description = Kodi is a free and open\-source media player which allows users to play and view most streaming media, such as videos, music, podcasts, and videos from the internet, as well as all common digital media files from local and network storage media. Its web interface runs at port 8080 of this server.
Unit = mediacenter.service
MeasureMethod = systemd
ActionMethod = Script
MeasurementInstrument = mediacenter.service
ActionInstrument = /home/osmc/kodi\-manager\-daemon/kodi\-manager\-daemon.sh
NavigateHref = http://example.com:8080

[sickrage]
Name = SiCKRAGE
Description = Automatic Video Library Manager for TV Shows. It watches for new episodes of your favorite shows, and when they are posted it does its magic. Supports Torrent providers such as ThePirateBay, SceneAccess, TorrentDay, Rarbg, and many others.
MeasureMethod = systemd\-user
ActionMethod = systemd\-user
MeasurementInstrument = sickrage.service
ActionInstrument = sickrage.service
NavigateHref = http://example.com:8081
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
genindex
.IP \(bu 2
modindex
.IP \(bu 2
search
.UNINDENT
.SH AUTHOR
chftyrol
.SH COPYRIGHT
2017, chftyrol
.\" Generated by docutils manpage writer.
.
